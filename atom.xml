<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>老骥伏枥</title>
  
  <subtitle>路虽远，行则将至；事虽难，做则可成。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jeremylj.github.io/"/>
  <updated>2023-05-26T15:00:18.324Z</updated>
  <id>https://jeremylj.github.io/</id>
  
  <author>
    <name>JeremyLJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>AspNetCore服务端读写浏览器Cookie</title>
    <link href="https://jeremylj.github.io/2023/05/18/aspnetcore-read-write-cookie/"/>
    <id>https://jeremylj.github.io/2023/05/18/aspnetcore-read-write-cookie/</id>
    <published>2023-05-18T15:05:17.000Z</published>
    <updated>2023-05-26T15:00:18.324Z</updated>
    
    <content type="html"><![CDATA[<p>现在大部分的Web网站都应该采用了前后端分离的架构，所以一般服务端都不用处理浏览器cookie相关的逻辑，前端根据需要将cookie数据以特定Http Request Header/Body的形式传给服务端API，并将API返回的Http Response Header以及Body的内容按需写入cookie。但凡事总有例外，如果前端和后端都是按照不同的功能模块以微服务的架构进行拆分，那么前端的多个不同页面很可能是由多个不同的开发团队来进行开发和部署的。对于某个特定模块的后端API被多个不同的前端页面调用，而该后端API若想通过浏览器cookie来在客户端和服务端之间保持一个特定的状态标识，就需要考虑如何实现可以将改动的范围限制在最小。一般情况下浏览器发起API请求默认都会带上cookie（跨域请求也可以主动传递cookie），所以主要改动还是各个页面将API返回的状态标识回写到cookie。为了不让调用API的每个页面（团队）都增加回写cookie的逻辑，可以仅在该服务端进行cookie更新设定，这样只需要修改一处，主要就是借助Http Response的Set-Cookie来实现。</p><p>另外需要修改的cookie很可能是多个页面模块共享，所以在修改cookie时，为了不破坏cookie原来的结构，或者说做到无损修改cookie，服务端在更新cookie之前，首先要找到目标cookie并解析原有的值。</p><p><em>PS:这里假设服务端是采用的是AspNetCore WebApi。</em></p><h3 id="服务端解析cookie"><a class="header-anchor" href="#服务端解析cookie">¶</a>服务端解析cookie</h3><h4 id="单个API里解析cookie"><a class="header-anchor" href="#单个API里解析cookie">¶</a>单个API里解析cookie</h4><p><strong>方法一</strong>：<br>最先想到的是直接解析HttpRequest的Cookie头，比如有如下的一个API来根据传入参数来解析对应的cookie的值。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"cookie/parse/&#123;cookieName&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">ParseTargetCookie</span>(<span class="params"><span class="keyword">string</span> cookieName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = Request.Headers.Cookie;  <span class="comment">// same as Request.Headers["Cookie"]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleCookiesList = Array.ConvertAll(cookie.First().Split(<span class="string">';'</span>, StringSplitOptions.RemoveEmptyEntries), c =&gt; c.Trim());</span><br><span class="line">    <span class="keyword">var</span> targetCookie = singleCookiesList.FirstOrDefault(c =&gt; c.StartsWith(cookieName))?.Replace(<span class="string">$"<span class="subst">&#123;cookieName&#125;</span>="</span>, <span class="keyword">string</span>.Empty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">string</span>.IsNullOrEmpty(targetCookie) ? <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, StringValues&gt;() : QueryHelpers.ParseQuery(targetCookie);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Ok(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>若使用如下的请求参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;cookie1&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39;</span><br></pre></td></tr></table></figure><p><em>Note: 如果执行curl命令遇到证书认证的问题，可以增加<code>-k</code>参数关闭证书认证。</em></p><p>将会得到这样的返回结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;key1&quot;:[&quot;val1&quot;],&quot;key&quot;:[&quot;val&quot;]&#125;</span><br></pre></td></tr></table></figure><p>顺便说一下，即使请求头里包含不同的值的2个Cookie头，API里拿到的也是合并的Cookie请求内容。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;cookie2&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39; \</span><br><span class="line">--header &#39;Cookie: cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22&#39;</span><br></pre></td></tr></table></figure><p>API里Request.Headers[“Cookie”]得到的内容是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11; cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22</span><br></pre></td></tr></table></figure><p>所以得到返回结果是</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;key2&quot;:[&quot;val2&quot;],&quot;key22&quot;:[&quot;val22&quot;]&#125;</span><br></pre></td></tr></table></figure><p><strong>方法二</strong>：<br>我们可以借助Request.Cookies（类型IRequestCookieCollection）来获取已经解析好的Cookie键值对列表，这样就省去了自己去解析的过程。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"cookie/parse/v2/&#123;cookieName&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">ParseTargetCookieV2</span>(<span class="params"><span class="keyword">string</span> cookieName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IRequestCookieCollection requestCookieCollection = Request.Cookies;</span><br><span class="line">    <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookie <span class="keyword">in</span> requestCookieCollection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cookie.Key.Equals(cookieName, StringComparison.InvariantCultureIgnoreCase))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = QueryHelpers.ParseQuery(cookie.Value.Trim());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">"Not Found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果跟方法一是一致的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request:</span><br><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;v2&#x2F;cookie1&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39;</span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">&#123;&quot;key1&quot;:[&quot;val1&quot;],&quot;key&quot;:[&quot;val&quot;]&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">Request:</span><br><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;v2&#x2F;cookie2&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39; \</span><br><span class="line">--header &#39;Cookie: cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22&#39;</span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">&#123;&quot;key2&quot;:[&quot;val2&quot;],&quot;key22&quot;:[&quot;val22&quot;]&#125;</span><br></pre></td></tr></table></figure><p>如果所有的API都需要解析cookie的话，可以考虑把上面的代码放到middleware里实现，Http Request可以通过HttpContext.Request来获取。</p><h3 id="服务端更新cookie"><a class="header-anchor" href="#服务端更新cookie">¶</a>服务端更新cookie</h3><p>前一部分实现了在服务端解析cookie，我们看下如何在服务端更新指定的cookie，准确的说是往指定的cookie里插入一个特定的key/value（若存在就更新）。更新cookie的逻辑既可以针对某个特定的API，也可以在middleware里对所有的Http请求进行统一处理。下面我们看下如何在middleware里对cookie进行更新。</p><p>示例代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpsertCookieMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpsertCookieMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        context.Response.OnStarting(UpsertCookie, context);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Task <span class="title">UpsertCookie</span>(<span class="params"><span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> context = (HttpContext)state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> targetCookieName = <span class="string">"cookie11"</span>;</span><br><span class="line">        context.Request.Cookies.TryGetValue(targetCookieName, <span class="keyword">out</span> <span class="keyword">var</span> cookieFromRequest);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(cookieFromRequest))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// no change if the target cookie doesn't exist in request</span></span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookieKvMap = QueryHelpers.ParseQuery(cookieFromRequest);</span><br><span class="line">        </span><br><span class="line">        cookieKvMap[<span class="string">"newKey"</span>] = <span class="string">"newVal"</span> + DateTime.Now.Millisecond;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookieString = <span class="keyword">string</span>.Join(<span class="string">"&amp;"</span>, cookieKvMap.Select(kv =&gt; <span class="string">$"<span class="subst">&#123;kv.Key&#125;</span>=<span class="subst">&#123;kv.Value&#125;</span>"</span>));</span><br><span class="line">        </span><br><span class="line">        context.Response.Cookies.Append(targetCookieName, cookieString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意：如果按照正常的逻辑，用如下的代码往Http Response里写入cookie：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> _next(context);</span><br><span class="line"></span><br><span class="line">    UpsertCookie(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行代码后发现，会报下面这个错误：<br><code>The response headers cannot be modified because the response has already started.</code></p><p>所以往Http Response回写cookie必须要在Response开始生成之前，我们可以借助context.Response.OnStarting()<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>来实现。context.Response.OnStarting()用来注册一个回调callback，在Response开始生成之前会被执行，回调的执行顺序与注册顺序相反，意思就是最后注册的回调，最先被执行。</p><p>通过Postman测试可以发现Response里有回写的cookie内容了。<br><img src="aspnetcore_write_cookie_postman_test.PNG" alt="Postman测试结果"></p><p>另外，如果需求是目标cookie的upsert需要基于Request传入的cookie值，那如果目标cookie的值被其他的middleware或者WebApi修改了，我们需要将其删除后，重新进行upsert。示例代码如下<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setCookieHeaders = context.Response.GetTypedHeaders().SetCookie;</span><br><span class="line"><span class="keyword">var</span> targetCookie = setCookieHeaders.FirstOrDefault(c =&gt; c.Name == <span class="string">"cookie11"</span>);</span><br><span class="line"><span class="keyword">if</span>(targetCookie != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    context.Response.Cookies.Delete(targetCookie.Name.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是AspNetCore服务端读写cookie的内容。</p><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>服务端读写cookie在传统的AspNet MVC架构是十分常规的操作，本篇借助了context.Response.OnStarting()注册回调来将cookie回写到Response中，这种实现方式相对优雅一些。</p><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><p>Demo代码已上传 <a href="https://github.com/jeremyLJ/aspnetcore_read_write_cookie" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore_read_write_cookie</a></p><h3 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h3><ol><li><a href="https://www.codeguru.com/dotnet/asp-net-cookies/" target="_blank" rel="noopener">https://www.codeguru.com/dotnet/asp-net-cookies/</a></li><li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware</a></li><li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write</a></li></ol><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.onstarting" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.onstarting</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://stackoverflow.com/questions/36899875/how-can-i-check-for-a-response-cookie-in-asp-net-core-mvc-aka-asp-net-5-rc1" target="_blank" rel="noopener">https://stackoverflow.com/questions/36899875/how-can-i-check-for-a-response-cookie-in-asp-net-core-mvc-aka-asp-net-5-rc1</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在大部分的Web网站都应该采用了前后端分离的架构，所以一般服务端都不用处理浏览器cookie相关的逻辑，前端根据需要将cookie数据以特定Http Request Header/Body的形式传给服务端API，并将API返回的Http Response Header以及
      
    
    </summary>
    
    
    
      <category term="dotNetCore" scheme="https://jeremylj.github.io/tags/dotNetCore/"/>
    
      <category term="serverSideCookie" scheme="https://jeremylj.github.io/tags/serverSideCookie/"/>
    
      <category term="WebApi" scheme="https://jeremylj.github.io/tags/WebApi/"/>
    
  </entry>
  
  <entry>
    <title>（四）配置AspNetCore gRPC使用HTTP</title>
    <link href="https://jeremylj.github.io/2021/01/09/aspnetcore-grpc-without-tls/"/>
    <id>https://jeremylj.github.io/2021/01/09/aspnetcore-grpc-without-tls/</id>
    <published>2021-01-09T15:10:45.000Z</published>
    <updated>2021-01-30T03:57:42.199Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC是基于HTTP2的，同时支持Http和Https协议。在开发环境，AspNetCore gRPC模板项目默认是使用TLS的，并通过开发证书来提供Https访问，这就是我们在<a href="https://jeremylj.github.io/2020/12/30/aspnetcore_grpc_start/#%E8%BF%90%E8%A1%8CgRPC%E6%9C%8D%E5%8A%A1">（一）AspNetCore集成gRPC体验</a>中遇到的，当第一次运行gRPC服务时，会看到一个提示安装和信任证书的确认框。</p><p>但是我们在实际使用中，gRPC更多的是使用在内网服务之间的通信，无疑Http协议比Https的效率要更高<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。接下来我们就看下如何配置gRPC服务来实现Http访问。</p><h3 id="服务端Kestrel配置"><a class="header-anchor" href="#服务端Kestrel配置">¶</a>服务端Kestrel配置</h3><p>Kestrel服务器可以配置支持HTTP1.1和HTTP2，如果要实现没有TLS的HTTP2连接，那么Kestrel服务器的协议必须使用HTTP2<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。具体配置代码如下：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IHostBuilder <span class="title">CreateHostBuilder</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span> =&gt;</span><br><span class="line">                Host.CreateDefaultBuilder(args)</span><br><span class="line">                    .ConfigureWebHostDefaults(webBuilder =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        webBuilder.ConfigureKestrel(options =&gt;</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="comment">// Setup HTTP2 without TLS</span></span><br><span class="line">                            options.ListenAnyIP(<span class="number">5000</span>, listenOptions =&gt;</span><br><span class="line">                            &#123;</span><br><span class="line">                                listenOptions.Protocols = HttpProtocols.Http2;  <span class="comment">// &lt;-- this line</span></span><br><span class="line">                            &#125;);</span><br><span class="line">                        &#125;);</span><br><span class="line">                        webBuilder.UseStartup&lt;Startup&gt;();</span><br><span class="line">                    &#125;);</span><br></pre></td></tr></table></figure><p>增加如上配置代码后，再启动服务器后发现服务监听在地址<code>http://[::]:5000</code>了，同时日志输出的内容稍稍有点不同了。<br><img src="http2_without_tls.PNG" alt=""></p><h3 id="客户端调用gRPC服务设置"><a class="header-anchor" href="#客户端调用gRPC服务设置">¶</a>客户端调用gRPC服务设置</h3><p>服务端的Http协议配置好后，那客户端调用要怎么设置才能成功调用呢？其实客户端只要设置如下一个<code>Http2UnencryptedSupport</code>变量的值就可以了<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This switch must be set before creating the GrpcChannel/HttpClient.</span></span><br><span class="line">AppContext.SetSwitch(</span><br><span class="line">    <span class="string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span class="literal">true</span>);</span><br></pre></td></tr></table></figure><p><strong>注意：这个变量的设置必须在创建gRPC连接通道或者HttpClient客户端之前</strong></p><h4 id="Net客户端"><a class="header-anchor" href="#Net客户端">¶</a>.Net客户端</h4><p>下面就是.Net客户端调用的设置，除了增加变量开关的设置，还需修改服务端的地址为Http。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// This switch must be set before creating the GrpcChannel/HttpClient.</span></span><br><span class="line">    AppContext.SetSwitch(</span><br><span class="line">        <span class="string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"http://localhost:5000"</span>);</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(channel);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> response = client.SayHello(<span class="keyword">new</span> HelloRequest</span><br><span class="line">    &#123;</span><br><span class="line">        Name = <span class="string">"gRPC"</span></span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(response.Message);</span><br><span class="line"></span><br><span class="line">    Console.ReadKey();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="AspNetCore客户端"><a class="header-anchor" href="#AspNetCore客户端">¶</a>AspNetCore客户端</h4><p>如果是AspNetCore客户端的话，则需要在Startup.cs文件里增加变量开关配置。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ConfigureServices</span>(<span class="params">IServiceCollection services</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    services.AddControllers();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This switch must be set before creating the GrpcChannel/HttpClient.</span></span><br><span class="line">    AppContext.SetSwitch(</span><br><span class="line">        <span class="string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span>, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    services.AddGrpcClient&lt;Greet.Greeter.GreeterClient&gt;(options =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        options.Address = <span class="keyword">new</span> Uri(<span class="string">"http://localhost:5000"</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>到这里我们就把如何配置gRPC服务支持HTTP协议，以及客户端如何调用搞清楚了。但是客户端的调用之前要增加这么一个开关配置不是特别优雅，不过这点在 .Net 5里面已经得到了优化，不再需要单独的设置了。</p><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><p>Demo代码已经上传 <a href="https://github.com/jeremyLJ/aspnetcore-grpc-demo/tree/grpc-without-tls" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore-grpc-demo/tree/grpc-without-tls</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://www.cnblogs.com/stulzq/p/11697269.html" target="_blank" rel="noopener">https://www.cnblogs.com/stulzq/p/11697269.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#protocol-negotiation" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#protocol-negotiation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-3.0&amp;WT.mc_id=DT-MVP-5003133#call-insecure-grpc-services-with-net-core-client" target="_blank" rel="noopener">https://docs.microsoft.com/en-us/aspnet/core/grpc/troubleshoot?view=aspnetcore-3.0&amp;WT.mc_id=DT-MVP-5003133#call-insecure-grpc-services-with-net-core-client</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gRPC是基于HTTP2的，同时支持Http和Https协议。在开发环境，AspNetCore gRPC模板项目默认是使用TLS的，并通过开发证书来提供Https访问，这就是我们在&lt;a href=&quot;https://jeremylj.github.io/2020/12/30/
      
    
    </summary>
    
    
    
      <category term="dotNetCore" scheme="https://jeremylj.github.io/tags/dotNetCore/"/>
    
      <category term="gRPC" scheme="https://jeremylj.github.io/tags/gRPC/"/>
    
      <category term="TLS" scheme="https://jeremylj.github.io/tags/TLS/"/>
    
  </entry>
  
  <entry>
    <title>（三）通过AspNetCore客户端访问AspNetCore Grpc服务</title>
    <link href="https://jeremylj.github.io/2021/01/06/aspnetcore-grpc-client-aspnetcore/"/>
    <id>https://jeremylj.github.io/2021/01/06/aspnetcore-grpc-client-aspnetcore/</id>
    <published>2021-01-06T14:11:40.000Z</published>
    <updated>2021-01-06T15:13:03.910Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://jeremylj.github.io/2021/01/04/aspnetcore-grpc-client-dotnet/">（二）通过.Net控制台客户端访问AspNetCore Grpc服务</a>我们知道如何通过.Net控制台客户端访问AspNetCore Grpc服务，本篇我们一起来看下如何通过AspNetCore客户端访问Grpc服务。</p><p>gRPC通过集成HttpClientFactory来提供一种集中的方式来创建gRPC客户端<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，接下来我们就借助HttpClientFactory来实现AspNetCore客户端访问Grpc服务。</p><ol><li><p>首先打开我们之前创建的<code>MyGrpcService.sln</code>解决方案，新建一个AspNetCore WebApi工程，工程名称就叫MyGrpcAspNetCoreClient，Framework版本为.NetCore3.1。<br><img src="aspnetcore_project.PNG" alt=""></p></li><li><p>因为HttpClientFactory功能通过Grpc.Net.ClientFactory包提供，所以我们安装下这个nuget包。</p></li><li><p>在添加proto文件之前，需要先安装Grpc.Tools nuget包，不然无法将proto文件编译成代理契约类。另外，nuget包Google.Protobuf也是必须要安装的。</p></li><li><p>在项目里新建一个Protos文件夹，将greet.proto文件通过链接(Link)的方式添加到项目中的Protos文件夹下（这里项目中的文件夹名字不一定非要是Protos，可以自定义）。</p></li><li><p>这里对MyGrpcAspNetCoreClient工程文件需要设置一下<code>GrpcServices=&quot;Client&quot;</code>，表示proto文件用来生成客户端契约代理类，设置如下：</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">    &lt;Protobuf Include=<span class="string">"..\..\Protos\greet.proto"</span> GrpcServices=<span class="string">"Client"</span>&gt;</span><br><span class="line">    &lt;Link&gt;Protos\greet.proto&lt;/Link&gt;</span><br><span class="line">    &lt;/Protobuf&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure><p>执行完上面的操作后，解决方案代码的目录看起来应该是这样的。<br><img src="aspnetcore_project_structure.PNG" alt=""></p></li><li><p>现在我们来添加gRPC客户端的创建代码，打开Startup.cs文件，在ConfigureServices的最后增加如下代码：</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">services.AddGrpcClient&lt;Greet.Greeter.GreeterClient&gt;(options =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    options.Address = <span class="keyword">new</span> Uri(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样GreeterClient就以transient方式注册到IOC容器中了，在需要使用的类中，直接通过构造器注入即可。</p></li><li><p>接下来我们在WeatherForecastController WebApi控制器中新增一个<code>grpc</code>的HttpGet Api来通过GreeterClient发起gRPC服务调用。</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"grpc"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task&lt;IActionResult&gt; <span class="title">InvokeGrpcHello</span>(<span class="params"><span class="keyword">string</span> name</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">await</span> _client.SayHelloAsync(<span class="keyword">new</span> Greet.HelloRequest</span><br><span class="line">    &#123;</span><br><span class="line">        Name = name</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(result.Message);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先运行gRPC服务端，在运行AspNetCore客户端，并在浏览器中输入name参数，类似<code>http://localhost:51250/weatherforecast/grpc?name=AspNetCoreGrpc</code>，如果运行正常的话将看到如下内容：<br><img src="aspnetcore_grpc_output.PNG" alt=""></p></li></ol><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>到这里我们就通过AspNetCore WebApi完成了gRPC服务的调用，可以看到并不需要很多代码就可以做到。下一篇我们将看下怎么实现通过Http的方式（基于HTTP2协议而不需要TLS）来访问gPRC服务。</p><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><p>Demo代码已经上传 <a href="https://github.com/jeremyLJ/aspnetcore-grpc-demo" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore-grpc-demo</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/clientfactory?view=aspnetcore-3.1" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/core/grpc/clientfactory?view=aspnetcore-3.1</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上一篇&lt;a href=&quot;https://jeremylj.github.io/2021/01/04/aspnetcore-grpc-client-dotnet/&quot;&gt;（二）通过.Net控制台客户端访问AspNetCore Grpc服务&lt;/a&gt;我们知道如何通过.Net控制台客户
      
    
    </summary>
    
    
    
      <category term="dotNetCore" scheme="https://jeremylj.github.io/tags/dotNetCore/"/>
    
      <category term="gRPC" scheme="https://jeremylj.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>（二）通过.Net控制台客户端访问AspNetCore Grpc服务</title>
    <link href="https://jeremylj.github.io/2021/01/04/aspnetcore-grpc-client-dotnet/"/>
    <id>https://jeremylj.github.io/2021/01/04/aspnetcore-grpc-client-dotnet/</id>
    <published>2021-01-04T14:20:49.000Z</published>
    <updated>2021-01-06T14:22:35.789Z</updated>
    
    <content type="html"><![CDATA[<p>通过前一篇<a href="https://jeremylj.github.io/2020/12/30/aspnetcore_grpc_start">（一）AspNetCore集成gRPC体验</a>，我们创建了一个AspNetCore gRPC服务，现在我们就来看下如何通过.Net控制台客户端来访问gRPC服务的SayHello方法<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><ol><li><p>首先打开我们之前创建的<code>MyGrpcService.sln</code>解决方案，新建一个控制台类型的.NetCore工程，工程名称就叫MyGrpcNetClient，Framework版本为.NetCore3.1，并安装下面三个nuget包：</p><ul><li>Grpc.Net.Client（选择安装目前的最新版本2.34.0）：包含gRPC功能的.NetCore客户端；</li><li>Google.Protobuf（选择安装目前的最新版本3.14.0）：包含针对C#的protobuf消息APIs；</li><li>Grpc.Tools（选择安装目前的最新版本2.34.0）：包含protobuf文件的C#工具支持；</li></ul></li><li><p>导入或引用服务端定义的greet.proto文件，这里为了避免proto文件被复制到多处后可能产生版本不一致的问题，所以我们将Protos文件夹移动到与解决方案同一层目录，原来的服务端和新建的客户端都通过引用(Link)的方式导入proto文件，这样做还有有一些其他的好处，后续我们会说到。</p><ul><li>在gRPC服务项目里，新建一个Protos文件夹（如果没有的话），将greet.proto文件通过引用的方式添加到项目中的Protos文件夹下（这里项目中的文件夹名字不一定非要是Protos，可以自定义），如图：<br><img src="add_proto_as_link.PNG" alt=""></li><li>确保代码能编译通过；</li><li>在上面新建的MyGrpcNetClient客户端项目中，也同样执行上面的操作；</li><li>这里对MyGrpcNetClient项目文件需要设置一下<code>GrpcServices=&quot;Client&quot;</code>，表示proto文件用来生成客户端契约代理类，设置如下  <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;ItemGroup&gt;</span><br><span class="line">    &lt;Protobuf Include=<span class="string">"..\..\Protos\greet.proto"</span> GrpcServices=<span class="string">"Client"</span>&gt;</span><br><span class="line">        &lt;Link&gt;Protos\greet.proto&lt;/Link&gt;</span><br><span class="line">    &lt;/Protobuf&gt;</span><br><span class="line">&lt;/ItemGroup&gt;</span><br></pre></td></tr></table></figure></li></ul><p>执行完上面的操作后，解决方案代码的目录看起来应该是这样的。<br><img src="solution_structure.PNG" alt=""></p></li><li><p>因为我们现在是共享proto文件，为了避免在服务端和客户端重复指定名称空间，我们把greet.proto中的<code>csharp_namespace</code>定义 <s>option csharp_namespace = “MyGrpcService”;</s> 去掉，通过包名来标识。相应的修改下GreeterService.cs名称空间使得代码编译通过。</p></li><li><p>现在我们来添加实际的客户端调用gRPC服务的代码，打开MyGrpcNetClient项目中的Program.cs文件，并增加如下内容：</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Program</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> channel = GrpcChannel.ForAddress(<span class="string">"https://localhost:5001"</span>);</span><br><span class="line">        <span class="keyword">var</span> client = <span class="keyword">new</span> Greeter.GreeterClient(channel);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> response = client.SayHello(<span class="keyword">new</span> HelloRequest</span><br><span class="line">        &#123;</span><br><span class="line">            Name = <span class="string">"gRPC"</span></span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(response.Message);</span><br><span class="line"></span><br><span class="line">        Console.ReadKey();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>先运行gRPC服务端，在运行客户端，最终我们将看到如下内容：<br><img src="grpc_output.PNG" alt=""></p></li></ol><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>到这里我们就通过 .Net Console App完成了gRPC服务的调用，客户端代码写起来是不是很简洁。接下来我们将看下怎么通过AspNetCore的客户端来访问这个SayHello的gPRC服务。</p><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><p>Demo代码已经上传 <a href="https://github.com/jeremyLJ/aspnetcore-grpc-demo" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore-grpc-demo</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-3.1&amp;tabs=visual-studio#create-the-grpc-client-in-a-net-console-app" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/core/tutorials/grpc/grpc-start?view=aspnetcore-3.1&amp;tabs=visual-studio#create-the-grpc-client-in-a-net-console-app</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;通过前一篇&lt;a href=&quot;https://jeremylj.github.io/2020/12/30/aspnetcore_grpc_start&quot;&gt;（一）AspNetCore集成gRPC体验&lt;/a&gt;，我们创建了一个AspNetCore gRPC服务，现在我们就来看下如何通
      
    
    </summary>
    
    
    
      <category term="dotNetCore" scheme="https://jeremylj.github.io/tags/dotNetCore/"/>
    
      <category term="gRPC" scheme="https://jeremylj.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>通过SSH连接GitHub</title>
    <link href="https://jeremylj.github.io/2021/01/01/connect-github-by-ssh/"/>
    <id>https://jeremylj.github.io/2021/01/01/connect-github-by-ssh/</id>
    <published>2021-01-01T10:48:53.000Z</published>
    <updated>2021-04-24T14:16:45.141Z</updated>
    
    <content type="html"><![CDATA[<p>之前一直使用账号密码的方式连接GitHub，进行远程仓库代码的拉取和推送，因为账号密码认证的小窗口会记住账号密码，所以感觉也还挺方便的。不过GitHub出了新规：Git操作的身份验证将放弃密码<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，改用令牌或SSH密钥<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>。下面截图是博主最近使用密码进行GitHub认证后，GitHub注册邮箱收到的一封提醒邮件。<br><img src="github_credential.PNG" alt="GitHub账号密码认证"><br><img src="github_pwd_deprecition.PNG" alt="GitHub将停止密码认证"></p><p>目前虽然还是能通过输入账号密码进行GitHub认证，但是最近博主发现在弹出窗口即使输入了正确的账号密码依然认证失败，必须得在接下来的Git命令行再次输入账号密码才能验证通过。这样每次提交或拉取远程仓库的代码就不那么方便了。</p><p>那我们就来看看如何通过SSH连接GitHub，它真的有那么香吗？！</p><p>话不多说，我们直接去找官方文档试验一把，官方文档可以通过登录GitHub后，进入个人设置，打开SSH and GPG keys菜单，发现<code>SSH keys</code>下面有句话，点击打开<code>generating SSH keys</code>链接即是文档说明。你也可以直接打开本文底部的链接<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup>。<br><img src="github_generate_ssh.PNG" alt="找到生成SSH key文档链接"></p><h3 id="SSH协议和SSH-keys"><a class="header-anchor" href="#SSH协议和SSH-keys">¶</a>SSH协议和SSH keys</h3><p>文档<sup class="footnote-ref"><a href="#fn3" id="fnref3:1">[3:1]</a></sup>描述的还是非常清楚的，首先说明了SSH协议和SSH key：使用SSH协议可以连接和认证远程服务器和服务。使用SSH keys可以在连接GitHub时，不用每次都输入用户名和密码。</p><p><em><strong>说明：以下操作均是基于Windows，Mac或Linux请参考文档的相应说明。</strong></em></p><h3 id="检查本机是否存在SSH-keys"><a class="header-anchor" href="#检查本机是否存在SSH-keys">¶</a>检查本机是否存在SSH keys</h3><p>在生成新的SSH keys之前，我们可以看下之前是否有意或无意的生成过。</p><ol><li>打开Git Bash命令行窗口，输入如下命令: <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls -al ~&#x2F;.ssh</span><br></pre></td></tr></table></figure></li><li>看一下输出内容里有没有*.pub后缀的文件名，类似以下的这些文件：<ul><li>id_rsa.pub</li><li>id_ecdsa.pub</li><li>id_ed25519.pub</li></ul></li><li>如果有的话，说明以前生成过SSH keys，就不用重新生成了，可以直接进入<code>将SSH key添加到GitHub账号</code>步骤。如果看到如下的输入内容，说明没有现成的SSH public keys，那我们就生成一个新的SSH key。<br><img src="check_ssh_key_exist.PNG" alt=""></li></ol><h3 id="生成新的SSH-key"><a class="header-anchor" href="#生成新的SSH-key">¶</a>生成新的SSH key</h3><ol><li><p>打开Git Bash或者在上一步打开的命令行窗口继续</p></li><li><p>输入下面一行命令，注意邮箱为你注册的GitHub邮箱。另外该命令执行过程中有3处需要交互的输入确认。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C &quot;your_email@example.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>第一个交互输入确认是存放SSH key文件的路径<code>Enter file in which to save the key</code>，一般来说只要直接按回车Enter键保留默认配置就行了，比如博主的默认存放文件具体位置如下图：<br><img src="ssh_key_location.PNG" alt=""></p><p><em>上面截图的是私钥/公钥对，带有pub后缀的为公钥文件。</em></p></li><li><p>第二和第三个交互输入确认是录入SSH key的密码，以及再次确认。这里我们可以输入自己能记住而又相对安全的密码。</p></li><li><p>新的SSH key生成成功将会看到如下的输出内容：<br><img src="generate_ssh_key.PNG" alt=""></p></li></ol><h3 id="将SSH-key添加到GitHub账号"><a class="header-anchor" href="#将SSH-key添加到GitHub账号">¶</a>将SSH key添加到GitHub账号</h3><ol><li><p>将SSH key的公钥复制到粘贴板，可以执行如下命令，也可以直接打开文件进行复制：</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clip &lt; ~&#x2F;.ssh&#x2F;id_ed25519.pub</span><br></pre></td></tr></table></figure></li><li><p>使用上面用来生成SSH key的邮箱登录GitHub后，进入个人设置，打开SSH and GPG keys菜单，点击SSH Keys旁边的<code>New SSH Key</code>，将SSH key粘贴进去。标题设置，可以按home、work分，也可以按PC、Notepad分，完全看个人喜好了。<br><img src="add_ssh_key.PNG" alt=""></p></li><li><p>点击<code>Add SSH key</code>完成添加，如果需要，按要求输入GitHub密码即可。</p></li></ol><h3 id="测试SSH连接"><a class="header-anchor" href="#测试SSH连接">¶</a>测试SSH连接</h3><p>当我们创建好SSH key并且添加到GitHub之后，可以测试下SSH连接是否正常。</p><ol><li>依然在Git Bash命令行，执行命令来尝试连接到GitHub <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li><li>当看到是否继续连接确认时，输入[<strong>yes</strong>]，然后看到如下输出内容时，说明连接设置成功了。<br><img src="test_ssh_connection.PNG" alt=""></li></ol><h3 id="体验SSH-key连接"><a class="header-anchor" href="#体验SSH-key连接">¶</a>体验SSH key连接</h3><ol><li><p>我们直接在已有的代码文件夹下，右键打开Git Bash命令行，熟练的输入git pull，看看能否正常执行。哎，不对啊，怎么还是弹出之前那个需要输入GitHub账号密码的弹窗啊。我们通过执行如下命令，来看下目前连接GitHub的方式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>我们看到输出是类似如下的内容，原来是因为连接GitHub代码库的方式还是Https的方式。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;jeremyLJ&#x2F;repository.git (fetch)    </span><br><span class="line">origin  https:&#x2F;&#x2F;github.com&#x2F;jeremyLJ&#x2F;repository.git (push)</span><br></pre></td></tr></table></figure></li><li><p>那我们看下如何将原来通过https连接代码库的方式换成通过SSH的方式。</p><ul><li><p>我们先到GitHub上响应的代码仓库里找到SSH的连接字符，然后复制下来，如下图<br><img src="ssh_conn_string.PNG" alt=""></p></li><li><p>执行下面一行命令来修改连接方式</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote set-url origin git@github.com:jeremyLJ&#x2F;privateLab.git</span><br></pre></td></tr></table></figure></li></ul></li><li><p>现在我们再执行下<code>git remote -v</code>命令，就会发现连接GitHub代码库已经变成了SSH的方式（如下图）。</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:jeremyLJ&#x2F;privateLab.git (fetch)</span><br><span class="line">origin  git@github.com:jeremyLJ&#x2F;privateLab.git (push)</span><br></pre></td></tr></table></figure></li><li><p>这时我们再通过<code>git pull</code>命令来拉取远程仓库的更新，就会看到提示需要输入SSH key设置的密码，当输入正确的密码后，git命令就可以执行成功了。<br><img src="enter_ssh_pwd.PNG" alt=""></p></li><li><p>但是我们发现每次执行远程仓库相关的git命令都需要输入SSH key的密码，参考上面的截图，这的确比较安全，但是确实有点不太方便，那有没有办法不用每次都输入SSH key的密码呢？答案是肯定的。</p></li></ol><h3 id="将SSH-key添加到ssh-agent"><a class="header-anchor" href="#将SSH-key添加到ssh-agent">¶</a>将SSH key添加到ssh-agent</h3><p>可以通过在Git Bash窗口，手动启动ssh代理，并将SSH key添加进来，做到在<strong>当前</strong>Git Bash窗口<strong>只输入一次</strong>SSH key密码。</p><ol><li>打开代码库所在路径的Git Bash窗口，并在同一窗口执行下面一行命令来启动SSH代理。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &#96;ssh-agent -s&#96;</span><br></pre></td></tr></table></figure></li><li>依然是同一Git Bash窗口，将新生成的SSH key文件添加到SSH代理，需要输入生成SSH key第4步设置的密码。 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-add ~&#x2F;.ssh&#x2F;id_ed25519</span><br></pre></td></tr></table></figure></li><li>后面执行git pull以及git push就不用再次输入SSH key的密码了。</li></ol><p>现在看下来，虽然我们不用每次都输入SSH key的密码，只用输入一次，但是每次打开Git Bash窗口都需要手动启动SSH代理，并添加SSH key文件，感觉还是不太方便，那能不能自动的完成同样的操作呢？答案是可以的，通过配置脚本。</p><h3 id="Windows上自动启动SSH代理"><a class="header-anchor" href="#Windows上自动启动SSH代理">¶</a>Windows上自动启动SSH代理</h3><p>根据官方文档<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>的说明，通过配置可以在打开Git Bash或者Git Shell的时候自动运行SSH代理。具体的配置方法如下。</p><ol><li><p>复制以下内容并以文件名<code>.profile</code>保存到当前用户文件夹下，路径C:\Users&lt;当前用户名&gt;\</p> <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">env=~/.ssh/agent.env</span><br><span class="line"></span><br><span class="line">agent_load_env () &#123; test -f "$env" &amp;&amp; . "$env" &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line">agent_start () &#123;</span><br><span class="line">    (umask 077; ssh-agent &gt;| "$env")</span><br><span class="line">    . "$env" &gt;| /dev/null ; &#125;</span><br><span class="line"></span><br><span class="line">agent_load_env</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> agent_run_state: 0=agent running w/ key; 1=agent w/o key; 2= agent not running</span></span><br><span class="line">agent_run_state=$(ssh-add -l &gt;| /dev/null 2&gt;&amp;1; echo $?)</span><br><span class="line"></span><br><span class="line">if [ ! "$SSH_AUTH_SOCK" ] || [ $agent_run_state = 2 ]; then</span><br><span class="line">    agent_start</span><br><span class="line">    ssh-add</span><br><span class="line">elif [ "$SSH_AUTH_SOCK" ] &amp;&amp; [ $agent_run_state = 1 ]; then</span><br><span class="line">    ssh-add</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">unset env</span><br></pre></td></tr></table></figure></li><li><p>再打开Git Bash窗口时，就会直接提示输入SSH key的密码，验证通过后，后续的git pull以及git push等命令将不再需要验证SSH key，如图所示。<br><img src="ssh_agent_auto.PNG" alt=""></p><ul><li>这样在其他新开的Git Bash窗口中执行git命令也都不需要验证SSH key密码了，即使把一开始输入SSH key已启动SSH代理的Git Bash窗口关掉，也依然可以不用验证SSH key密码。</li><li>当然每次重启电脑后，再次打开Git Bash还是需要验证SSH key密码的。</li></ul></li></ol><p>目前来看，在Git Bash中借助自动启动SSH代理来一次性验证SSH连接已经比较方便了，毕竟每次重启电脑才需要再次输入SSH key密码进行SSH连接验证。但是大家都知道一些集成开发工具IDE也集成或支持Git插件，比如博主在Visual Studio Code中直接通过界面进行代码的Pull操作，发现git拉取远程仓库失败，报一个类似如下的错误。<br><img src="vscode_git_fail.PNG" alt=""></p><p>这个错误是什么意思呢，其实通过在终端窗口里执行git pull发现还是因为需要输入SSH key密码的问题，当输入了正确的SSH key密码后，git命令就执行成功了。<br><img src="vscode_git_ssh_key.PNG" alt=""></p><p>对于习惯通过界面进行git拉取和推送操作的小伙伴肯定觉得太不方便了，这时候还有最后一招就是把SSH key的密码重置，就是不设置密码，那样每次就不用验证了，不就一劳永逸了嘛！</p><h3 id="如何修改SSH-key密码"><a class="header-anchor" href="#如何修改SSH-key密码">¶</a>如何修改SSH key密码</h3><ol><li><p>我们可以通过命令<code>ssh-keygen -p</code>来修改或设置SSH key的密码。如果Git Bash当前所在的路径不在<code>C:\Users\&lt;当前用户名&gt;\.ssh</code>下的话，文件路径那里需要提供SSH私钥文件的完成路径，不然会报文件或路径不存在的错误。<br><img src="change_ssh_key_pwd.PNG" alt=""></p></li><li><p>新的SSH key密码输入和密码确认都是直接回车，表示没有密码。<br><strong>注意：去掉SSH key密码设置，虽然会带来一定的操作便捷性，同时安全性也就降低了，请大家自行判断！</strong></p></li><li><p>现在再去Visual Studio Code的界面执行git拉取或推送操作，就可以直接成功了，当然Git Bash也不再需要验证SSH key的密码了。</p></li></ol><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>关于通过SSH连接GitHub的分享就差不多了，如果大家在实际操作过程中遇到其他的问题，可以参考官方的问题排查文档链接<sup class="footnote-ref"><a href="#fn5" id="fnref5">[5]</a></sup>，里面列举了一些常见的错误答疑。</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://developer.github.com/changes/2020-02-14-deprecating-password-auth/" target="_blank" rel="noopener">Deprecating password authentication</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/" target="_blank" rel="noopener">https://github.blog/2020-12-15-token-authentication-requirements-for-git-operations/</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://docs.github.com/articles/generating-an-ssh-key/" target="_blank" rel="noopener">https://docs.github.com/articles/generating-an-ssh-key/</a> <a href="#fnref3" class="footnote-backref">↩︎</a> <a href="#fnref3:1" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/working-with-ssh-key-passphrases#auto-launching-ssh-agent-on-git-for-windows" target="_blank" rel="noopener">https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/working-with-ssh-key-passphrases#auto-launching-ssh-agent-on-git-for-windows</a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li><li id="fn5" class="footnote-item"><p><a href="https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/troubleshooting-ssh" target="_blank" rel="noopener">Trouble shooting</a> <a href="#fnref5" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前一直使用账号密码的方式连接GitHub，进行远程仓库代码的拉取和推送，因为账号密码认证的小窗口会记住账号密码，所以感觉也还挺方便的。不过GitHub出了新规：Git操作的身份验证将放弃密码&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; 
      
    
    </summary>
    
    
    
      <category term="git" scheme="https://jeremylj.github.io/tags/git/"/>
    
      <category term="github" scheme="https://jeremylj.github.io/tags/github/"/>
    
      <category term="ssh" scheme="https://jeremylj.github.io/tags/ssh/"/>
    
  </entry>
  
  <entry>
    <title>（一）AspNetCore集成gRPC体验</title>
    <link href="https://jeremylj.github.io/2020/12/30/aspnetcore_grpc_start/"/>
    <id>https://jeremylj.github.io/2020/12/30/aspnetcore_grpc_start/</id>
    <published>2020-12-30T14:07:18.000Z</published>
    <updated>2021-01-04T14:19:27.856Z</updated>
    
    <content type="html"><![CDATA[<p>gRPC最早是由Google开发，是一款现代、开源、高性能的RPC框架。默认gRPC使用Protocol Buffer作为服务的接口定义语言（Interface Definition Language, IDL）和信息交换格式，支持多种语言，支持客户端、服务器以及双向流式调用处理<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。</p><p>下面我们一起来看下如何基于AspNetCore来创建一个gRPC服务端（基于Windows10机器）。</p><h3 id="环境准备"><a class="header-anchor" href="#环境准备">¶</a>环境准备</h3><ul><li>Visual Studio 2019 16.4及以上版本 （当然也可以使用Visual Studio Code来开发）</li><li>dotNetCore SDK 3.1及以上版本</li></ul><p>博主使用的环境说明：</p><ul><li>Visual Studio 2019 Professional具体版本为：Version 16.5.5</li><li>安装的dotnet sdk版本信息如下：  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C:\Users\admin&gt;dotnet --list-sdks</span><br><span class="line">2.1.505 [C:\Program Files\dotnet\sdk]</span><br><span class="line">2.2.110 [C:\Program Files\dotnet\sdk]</span><br><span class="line">2.2.207 [C:\Program Files\dotnet\sdk]</span><br><span class="line">3.1.202 [C:\Program Files\dotnet\sdk]</span><br></pre></td></tr></table></figure></li></ul><h3 id="通过项目模板创建gRPC服务端"><a class="header-anchor" href="#通过项目模板创建gRPC服务端">¶</a>通过项目模板创建gRPC服务端</h3><ol><li><p>使用Visual Studio的gRPC模板快速创建包含默认实现的gRPC服务<br>通过输入<code>grpc</code>关键字选择项目模板<br><img src="vs_grpc_start_one.PNG" alt="第1步"></p></li><li><p>设置项目名称和文件存放路径<br><img src="vs_grpc_start_two.PNG" alt="第2步"></p></li><li><p>不需要设置Authentication，不需启用Docker Support，直接下一步<br><img src="vs_grpc_start_three.PNG" alt="第3步"></p></li><li><p>这样一个AspNetCore gRPC项目就创建好了，模板默认实现了一个GreetService，包含一个SayHello方法<br><img src="vs_grpc_start_four.PNG" alt="gRPC模板默认的项目结构"></p></li></ol><h3 id="熟悉模板项目中的文件及配置"><a class="header-anchor" href="#熟悉模板项目中的文件及配置">¶</a>熟悉模板项目中的文件及配置</h3><ol><li><p>第一眼看上去，发现Protos文件夹下面有一个greet.proto文件，*.proto扩展名的文件为ProtoBuf的定义文件，我们来看下这个文件的内容：</p> <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto3"</span>; <span class="comment">// 指定使用的protobuf版本，如果不指定，默认使用proto2。如果指定，则必须在文件的非空非注释的第一行。</span></span><br><span class="line"></span><br><span class="line">option csharp_namespace = <span class="string">"MyGrpcService"</span>; <span class="comment">// 指定C#的命名空间</span></span><br><span class="line"></span><br><span class="line">package greet; <span class="comment">// 定义包名称，该行是可选的,可以为.proto文件新增一个可选的package声明符，用来防止不同的消息类型有命名冲突</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 服务定义</span></span><br><span class="line">service Greeter &#123;</span><br><span class="line"><span class="comment">// 方法定义</span></span><br><span class="line"><span class="function">rpc <span class="title">SayHello</span> (<span class="params">HelloRequest</span>) <span class="title">returns</span> (<span class="params">HelloReply</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 请求消息模型</span></span><br><span class="line">message HelloRequest &#123;</span><br><span class="line"><span class="keyword">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 响应消息模型</span></span><br><span class="line">message HelloReply &#123;</span><br><span class="line"><span class="keyword">string</span> message = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据以上ProtoBuf的定义，ProtoBuf编译器<code>protoc</code>会自动在MyGrpcService命名空间下生成名为Greeter的gRPC服务契约<strong>抽像</strong>代理类，文件存放位置<code>\MyGrpcService\obj\Debug\netcoreapp3.1\GreetGrpc.cs</code>。</p></li><li><p>另外appsettings.json里最后有如下一个针对Kestrel服务器的配置，可以看到gRPC服务默认是使用HTTP/2来通信的。</p> <figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">"Kestrel": &#123;</span><br><span class="line">    "EndpointDefaults": &#123;</span><br><span class="line">        "Protocols": "Http2"</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>Kestrel服务端点可以通过配置来支持HTTP1.1、HTTP2或者同时支持二者。当服务端点支持多种协议的话，TLS(Transport Layer Security)应用程序层协议协商(Application-Layer Protocol Negotiation, ALPN) 握手可用于协商客户端与服务器之间的连接协议，此协商确定连接是使用HTTP/1.1还是HTTP/2。</p></li><li><p>如果在不使用TLS的情况下配置了HTTP/2服务端点，则必须将服务端点的ListenOptions.Protocols设置为<code>HttpProtocols.Http2</code>。因为没有TLS，如果使用具有多个协议（例如HttpProtocols.Http1AndHttp2）的服务端点，则没有办法协商。到不安全服务端点的所有连接均默认为HTTP/1.1，且gRPC调用会失败。<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup><br>后面我们可以专门写下“不使用TLS的情况下配置了HTTP/2服务端点”的场景，以及代码实现。</p></li></ul></li></ol><h3 id="如何实现gRPC服务"><a class="header-anchor" href="#如何实现gRPC服务">¶</a>如何实现gRPC服务</h3><ol><li>上面我们提到ProtoBuf编译器会根据proto文件自动生成gRPC服务契约抽象代理类，那如果要提供真正的gRPC服务，我们需要实现具体的服务契约方法。现在我们来打开Services\MyGrpcService.cs文件。<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">MyGrpcService</span></span><br><span class="line"> &#123;</span><br><span class="line">     public class GreeterService : Greeter.GreeterBase  // Greeter.GreeterBase即为上面所谓的gRPC服务契约抽象代理类</span><br><span class="line">     &#123;</span><br><span class="line">         <span class="keyword">private</span> <span class="keyword">readonly</span> ILogger&lt;GreeterService&gt; _logger;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="title">GreeterService</span>(<span class="params">ILogger&lt;GreeterService&gt; logger</span>)</span></span><br><span class="line"><span class="function"></span>         &#123;</span><br><span class="line">             _logger = logger;</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// 通过override来实现SayHello服务方法</span></span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> Task&lt;HelloReply&gt; <span class="title">SayHello</span>(<span class="params">HelloRequest request, ServerCallContext context</span>)</span></span><br><span class="line"><span class="function"></span>         &#123;</span><br><span class="line">             <span class="keyword">return</span> Task.FromResult(<span class="keyword">new</span> HelloReply</span><br><span class="line">             &#123;</span><br><span class="line">                 Message = <span class="string">"Hello "</span> + request.Name</span><br><span class="line">             &#125;);</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li>仅有上面的gRPC服务实现是不够的的，我们还需要将它映射到服务器端点路由里。对的，Startup.cs文件中下面的一行代码正是为了实现这样的效果。 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Configure</span>(<span class="params">IApplicationBuilder app, IWebHostEnvironment env</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    app.UseRouting();</span><br><span class="line"></span><br><span class="line">    app.UseEndpoints(endpoints =&gt;</span><br><span class="line">    &#123;</span><br><span class="line">        endpoints.MapGrpcService&lt;GreeterService&gt;();  <span class="comment">// &lt;---- 说的是这一行代码</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>既然打开了Startup.cs文件，那顺便再抬头往上看几行，发现在ConfigureServices方法中有一行代码<code>services.AddGrpc();</code>，没错，这一行代码表示需要启动的是gRPC服务。</li></ol><h3 id="运行gRPC服务"><a class="header-anchor" href="#运行gRPC服务">¶</a>运行gRPC服务</h3><p>说了那么多，现在我们把这个模板项目跑起来，看看神秘的gRPC服务运行起来到底是啥样的。</p><ol><li><p>在Visual Studio开发环境中，启动项目最直接的就是按下F5（当然也可以通过命令行dotnet run来启动）。通过Visual Stuido第一运行gRPC服务的时候，会弹出一个是否信任AspNetCore SSL证书的确认框，点击[<strong>Yes</strong>]即可，下一步点击[<strong>是</strong>]安装证书。<br><img src="vs_grpc_cert_dialog.PNG" alt=""><br><img src="vs_grpc_cert_install.PNG" alt=""></p></li><li><p>现在gRPC服务就可以跑起来了，你会看到如下的命令行输出，通过打出来的日志<code>https://localhost:5001</code>，https表明启动的是受TLS保护的服务端点。<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup><br><img src="aspnetcore_grpc_console.PNG" alt=""></p></li></ol><h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3><p>到这里我们就把一个基于AspNetCore的gRPC模板项目分析的差不多了，后续我们将继续探索如何实现一个客户端来访问这个SayHello的gPRC服务。</p><h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3><p>Demo代码已经上传 <a href="https://github.com/jeremyLJ/aspnetcore-grpc-demo" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore-grpc-demo</a></p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a href="https://grpc.io/docs/what-is-grpc/introduction" target="_blank" rel="noopener">https://grpc.io/docs/what-is-grpc/introduction</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#protocol-negotiation" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#protocol-negotiation</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="https://docs.microsoft.com/zh-cn/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#tls" target="_blank" rel="noopener">https://docs.microsoft.com/zh-cn/aspnet/core/grpc/aspnetcore?view=aspnetcore-3.0&amp;tabs=visual-studio#tls</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;gRPC最早是由Google开发，是一款现代、开源、高性能的RPC框架。默认gRPC使用Protocol Buffer作为服务的接口定义语言（Interface Definition Language, IDL）和信息交换格式，支持多种语言，支持客户端、服务器以及双向流式调
      
    
    </summary>
    
    
    
      <category term="dotNetCore" scheme="https://jeremylj.github.io/tags/dotNetCore/"/>
    
      <category term="gRPC" scheme="https://jeremylj.github.io/tags/gRPC/"/>
    
  </entry>
  
  <entry>
    <title>你好，博客</title>
    <link href="https://jeremylj.github.io/2020/04/10/hello/"/>
    <id>https://jeremylj.github.io/2020/04/10/hello/</id>
    <published>2020-04-10T11:23:27.000Z</published>
    <updated>2020-12-30T22:34:29.711Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
</feed>
