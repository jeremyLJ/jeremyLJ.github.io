<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>AspNetCore服务端读写浏览器Cookie | 老骥伏枥</title><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 4.2.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">AspNetCore服务端读写浏览器Cookie</h1><a id="logo" href="/.">老骥伏枥</a><p class="description">路虽远，行则将至；事虽难，做则可成。</p></div><div id="nav-menu"><a class="current" href="/."><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a><a href="/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">AspNetCore服务端读写浏览器Cookie</h1><div class="post-meta">2023-05-18</div><div class="post-content"><p>现在大部分的Web网站都应该采用了前后端分离的架构，所以一般服务端都不用处理浏览器cookie相关的逻辑，前端根据需要将cookie数据以特定Http Request Header/Body的形式传给服务端API，并将API返回的Http Response Header以及Body的内容按需写入cookie。但凡事总有例外，如果前端和后端都是按照不同的功能模块以微服务的架构进行拆分，那么前端的多个不同页面很可能是由多个不同的开发团队来进行开发和部署的。对于某个特定模块的后端API被多个不同的前端页面调用，而该后端API若想通过浏览器cookie来在客户端和服务端之间保持一个特定的状态标识，就需要考虑如何实现可以将改动的范围限制在最小。一般情况下浏览器发起API请求默认都会带上cookie（跨域请求也可以主动传递cookie），所以主要改动还是各个页面将API返回的状态标识回写到cookie。为了不让调用API的每个页面（团队）都增加回写cookie的逻辑，可以仅在该服务端进行cookie更新设定，这样只需要修改一处，主要就是借助Http Response的Set-Cookie来实现。</p>
<p>另外需要修改的cookie很可能是多个页面模块共享，所以在修改cookie时，为了不破坏cookie原来的结构，或者说做到无损修改cookie，服务端在更新cookie之前，首先要找到目标cookie并解析原有的值。</p>
<p><em>PS:这里假设服务端是采用的是AspNetCore WebApi。</em></p>
<h3 id="服务端解析cookie"><a class="header-anchor" href="#服务端解析cookie">¶</a>服务端解析cookie</h3>
<h4 id="单个API里解析cookie"><a class="header-anchor" href="#单个API里解析cookie">¶</a>单个API里解析cookie</h4>
<p><strong>方法一</strong>：<br>
最先想到的是直接解析HttpRequest的Cookie头，比如有如下的一个API来根据传入参数来解析对应的cookie的值。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"cookie/parse/&#123;cookieName&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">ParseTargetCookie</span>(<span class="params"><span class="keyword">string</span> cookieName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">var</span> cookie = Request.Headers.Cookie;  <span class="comment">// same as Request.Headers["Cookie"]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> singleCookiesList = Array.ConvertAll(cookie.First().Split(<span class="string">';'</span>, StringSplitOptions.RemoveEmptyEntries), c =&gt; c.Trim());</span><br><span class="line">    <span class="keyword">var</span> targetCookie = singleCookiesList.FirstOrDefault(c =&gt; c.StartsWith(cookieName))?.Replace(<span class="string">$"<span class="subst">&#123;cookieName&#125;</span>="</span>, <span class="keyword">string</span>.Empty);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">string</span>.IsNullOrEmpty(targetCookie) ? <span class="keyword">new</span> Dictionary&lt;<span class="keyword">string</span>, StringValues&gt;() : QueryHelpers.ParseQuery(targetCookie);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Ok(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若使用如下的请求参数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;cookie1&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39;</span><br></pre></td></tr></table></figure>
<p><em>Note: 如果执行curl命令遇到证书认证的问题，可以增加<code>-k</code>参数关闭证书认证。</em></p>
<p>将会得到这样的返回结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;key1&quot;:[&quot;val1&quot;],&quot;key&quot;:[&quot;val&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>顺便说一下，即使请求头里包含不同的值的2个Cookie头，API里拿到的也是合并的Cookie请求内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;cookie2&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39; \</span><br><span class="line">--header &#39;Cookie: cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22&#39;</span><br></pre></td></tr></table></figure>
<p>API里Request.Headers[“Cookie”]得到的内容是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11; cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22</span><br></pre></td></tr></table></figure>
<p>所以得到返回结果是</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&quot;key2&quot;:[&quot;val2&quot;],&quot;key22&quot;:[&quot;val22&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p><strong>方法二</strong>：<br>
我们可以借助Request.Cookies（类型IRequestCookieCollection）来获取已经解析好的Cookie键值对列表，这样就省去了自己去解析的过程。</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[<span class="meta">HttpGet(<span class="meta-string">"cookie/parse/v2/&#123;cookieName&#125;"</span>)</span>]</span><br><span class="line"><span class="function"><span class="keyword">public</span> IActionResult <span class="title">ParseTargetCookieV2</span>(<span class="params"><span class="keyword">string</span> cookieName</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IRequestCookieCollection requestCookieCollection = Request.Cookies;</span><br><span class="line">    <span class="keyword">foreach</span>(KeyValuePair&lt;<span class="keyword">string</span>, <span class="keyword">string</span>&gt; cookie <span class="keyword">in</span> requestCookieCollection)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cookie.Key.Equals(cookieName, StringComparison.InvariantCultureIgnoreCase))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">var</span> result = QueryHelpers.ParseQuery(cookie.Value.Trim());</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> Ok(result);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Ok(<span class="string">"Not Found"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果跟方法一是一致的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Request:</span><br><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;v2&#x2F;cookie1&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39;</span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">&#123;&quot;key1&quot;:[&quot;val1&quot;],&quot;key&quot;:[&quot;val&quot;]&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------</span><br><span class="line">Request:</span><br><span class="line">curl -k --location &#39;https:&#x2F;&#x2F;localhost:44306&#x2F;demo&#x2F;cookie&#x2F;parse&#x2F;v2&#x2F;cookie2&#39; \</span><br><span class="line">--header &#39;Cookie: cookie1&#x3D;key1&#x3D;val1&amp;key&#x3D;val;cookie11&#x3D;key11&#x3D;val11&#39; \</span><br><span class="line">--header &#39;Cookie: cookie2&#x3D;key2&#x3D;val2&amp;key22&#x3D;val22&#39;</span><br><span class="line"></span><br><span class="line">Response:</span><br><span class="line">&#123;&quot;key2&quot;:[&quot;val2&quot;],&quot;key22&quot;:[&quot;val22&quot;]&#125;</span><br></pre></td></tr></table></figure>
<p>如果所有的API都需要解析cookie的话，可以考虑把上面的代码放到middleware里实现，Http Request可以通过HttpContext.Request来获取。</p>
<h3 id="服务端更新cookie"><a class="header-anchor" href="#服务端更新cookie">¶</a>服务端更新cookie</h3>
<p>前一部分实现了在服务端解析cookie，我们看下如何在服务端更新指定的cookie，准确的说是往指定的cookie里插入一个特定的key/value（若存在就更新）。更新cookie的逻辑既可以针对某个特定的API，也可以在middleware里对所有的Http请求进行统一处理。下面我们看下如何在middleware里对cookie进行更新。</p>
<p>示例代码如下：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">UpsertCookieMiddleware</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">readonly</span> RequestDelegate _next;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UpsertCookieMiddleware</span>(<span class="params">RequestDelegate next</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        _next = next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        context.Response.OnStarting(UpsertCookie, context);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">await</span> _next(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> Task <span class="title">UpsertCookie</span>(<span class="params"><span class="keyword">object</span> state</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="keyword">var</span> context = (HttpContext)state;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> targetCookieName = <span class="string">"cookie11"</span>;</span><br><span class="line">        context.Request.Cookies.TryGetValue(targetCookieName, <span class="keyword">out</span> <span class="keyword">var</span> cookieFromRequest);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">string</span>.IsNullOrEmpty(cookieFromRequest))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// no change if the target cookie doesn't exist in request</span></span><br><span class="line">            <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookieKvMap = QueryHelpers.ParseQuery(cookieFromRequest);</span><br><span class="line">        </span><br><span class="line">        cookieKvMap[<span class="string">"newKey"</span>] = <span class="string">"newVal"</span> + DateTime.Now.Millisecond;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> cookieString = <span class="keyword">string</span>.Join(<span class="string">"&amp;"</span>, cookieKvMap.Select(kv =&gt; <span class="string">$"<span class="subst">&#123;kv.Key&#125;</span>=<span class="subst">&#123;kv.Value&#125;</span>"</span>));</span><br><span class="line">        </span><br><span class="line">        context.Response.Cookies.Append(targetCookieName, cookieString);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Task.CompletedTask;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>注意：如果按照正常的逻辑，用如下的代码往Http Response里写入cookie：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">async</span> Task <span class="title">Invoke</span>(<span class="params">HttpContext context</span>)</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">await</span> _next(context);</span><br><span class="line"></span><br><span class="line">    UpsertCookie(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行代码后发现，会报下面这个错误：<br>
<code>The response headers cannot be modified because the response has already started.</code></p>
<p>所以往Http Response回写cookie必须要在Response开始生成之前，我们可以借助context.Response.OnStarting()<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>来实现。context.Response.OnStarting()用来注册一个回调callback，在Response开始生成之前会被执行，回调的执行顺序与注册顺序相反，意思就是最后注册的回调，最先被执行。</p>
<p>通过Postman测试可以发现Response里有回写的cookie内容了。<br>
<img src="aspnetcore_write_cookie_postman_test.PNG" alt="Postman测试结果"></p>
<p>另外，如果需求是目标cookie的upsert需要基于Request传入的cookie值，那如果目标cookie的值被其他的middleware或者WebApi修改了，我们需要将其删除后，重新进行upsert。示例代码如下<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>：</p>
<figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> setCookieHeaders = context.Response.GetTypedHeaders().SetCookie;</span><br><span class="line"><span class="keyword">var</span> targetCookie = setCookieHeaders.FirstOrDefault(c =&gt; c.Name == <span class="string">"cookie11"</span>);</span><br><span class="line"><span class="keyword">if</span>(targetCookie != <span class="literal">null</span>)</span><br><span class="line">&#123;</span><br><span class="line">    context.Response.Cookies.Delete(targetCookie.Name.Value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是AspNetCore服务端读写cookie的内容。</p>
<h3 id="结语"><a class="header-anchor" href="#结语">¶</a>结语</h3>
<p>服务端读写cookie在传统的AspNet MVC架构是十分常规的操作，本篇借助了context.Response.OnStarting()注册回调来将cookie回写到Response中，这种实现方式相对优雅一些。</p>
<h3 id="源码"><a class="header-anchor" href="#源码">¶</a>源码</h3>
<p>Demo代码已上传 <a href="https://github.com/jeremyLJ/aspnetcore_read_write_cookie" target="_blank" rel="noopener">https://github.com/jeremyLJ/aspnetcore_read_write_cookie</a></p>
<h3 id="参考资料"><a class="header-anchor" href="#参考资料">¶</a>参考资料</h3>
<ol>
<li><a href="https://www.codeguru.com/dotnet/asp-net-cookies/" target="_blank" rel="noopener">https://www.codeguru.com/dotnet/asp-net-cookies/</a></li>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware</a></li>
<li><a href="https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/aspnet/core/fundamentals/middleware/write</a></li>
</ol>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p><a href="https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.onstarting" target="_blank" rel="noopener">https://learn.microsoft.com/en-us/dotnet/api/microsoft.aspnetcore.http.httpresponse.onstarting</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
<li id="fn2" class="footnote-item"><p><a href="https://stackoverflow.com/questions/36899875/how-can-i-check-for-a-response-cookie-in-asp-net-core-mvc-aka-asp-net-5-rc1" target="_blank" rel="noopener">https://stackoverflow.com/questions/36899875/how-can-i-check-for-a-response-cookie-in-asp-net-core-mvc-aka-asp-net-5-rc1</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
</div><div class="tags"><a href="/tags/dotNetCore/"><i class="fa fa-tag"></i>dotNetCore</a><a href="/tags/serverSideCookie/"><i class="fa fa-tag"></i>serverSideCookie</a><a href="/tags/WebApi/"><i class="fa fa-tag"></i>WebApi</a></div><div class="post-nav"><a class="pre" href="/2023/05/28/aspnetcore-response-onstarting-unittest/">如何对HttpResponse.OnStarting()进行单元测试</a><a class="next" href="/2021/01/09/aspnetcore-grpc-without-tls/">（四）配置AspNetCore gRPC使用HTTP</a></div><div id="container"></div><link rel="stylesheet" type="text/css" href="//unpkg.com/gitalk/dist/gitalk.css?v=0.0.0"><script type="text/javascript" src="//cdn.bootcss.com/blueimp-md5/2.10.0/js/md5.js?v=0.0.0"></script><script type="text/javascript" src="//unpkg.com/gitalk/dist/gitalk.min.js?v=0.0.0"></script><script>var gitalk = new Gitalk({
  clientID: '64825436f9b51dde2873',
  clientSecret: 'fef89369acda7602d0bbf884b79d0458905ead5f',
  repo: 'jeremyLJ.github.io',
  owner: 'jeremyLJ',
  admin: ['jeremyLJ'],
  id: md5(location.pathname),
  distractionFreeMode: false
})
gitalk.render('container')
</script></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/dotNetCore/" style="font-size: 15px;">dotNetCore</a> <a href="/tags/gRPC/" style="font-size: 15px;">gRPC</a> <a href="/tags/TLS/" style="font-size: 15px;">TLS</a> <a href="/tags/git/" style="font-size: 15px;">git</a> <a href="/tags/github/" style="font-size: 15px;">github</a> <a href="/tags/ssh/" style="font-size: 15px;">ssh</a> <a href="/tags/serverSideCookie/" style="font-size: 15px;">serverSideCookie</a> <a href="/tags/WebApi/" style="font-size: 15px;">WebApi</a> <a href="/tags/unitTest/" style="font-size: 15px;">unitTest</a> <a href="/tags/responseOnStarting/" style="font-size: 15px;">responseOnStarting</a> <a href="/tags/moq/" style="font-size: 15px;">moq</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2023/06/17/aspnetcore-unittest-ilogger-moq/">单元测试中如何通过Moq测试ILogger方法</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/28/aspnetcore-response-onstarting-unittest/">如何对HttpResponse.OnStarting()进行单元测试</a></li><li class="post-list-item"><a class="post-list-link" href="/2023/05/18/aspnetcore-read-write-cookie/">AspNetCore服务端读写浏览器Cookie</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/09/aspnetcore-grpc-without-tls/">（四）配置AspNetCore gRPC使用HTTP</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/06/aspnetcore-grpc-client-aspnetcore/">（三）通过AspNetCore客户端访问AspNetCore Grpc服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/04/aspnetcore-grpc-client-dotnet/">（二）通过.Net控制台客户端访问AspNetCore Grpc服务</a></li><li class="post-list-item"><a class="post-list-link" href="/2021/01/01/connect-github-by-ssh/">通过SSH连接GitHub</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/12/30/aspnetcore_grpc_start/">（一）AspNetCore集成gRPC体验</a></li><li class="post-list-item"><a class="post-list-link" href="/2020/04/10/hello/">你好，博客</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.example1.com/" title="site-name1" target="_blank">site-name1</a><ul></ul><a href="http://www.example2.com/" title="site-name2" target="_blank">site-name2</a><ul></ul><a href="http://www.example3.com/" title="site-name3" target="_blank">site-name3</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2023 <a href="/." rel="nofollow">老骥伏枥.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>